#define _CRT_SECURE_NO_WARNINGS

#include<iostream>

//20221121
//int main()
//{
//
//	//引用
//	//int a = 0;
//
//	//int& refa = a;		//reference引用
//	//					//refa与右值绑定bind
//	//
//	//std::cout << refa++ << std::endl;
//	//std::cout << a << std::endl;
//
//	// //int& refb;			//refb必须初始化
//	//
//	//int i1 = 0, i2 = 0;
//	//int& refi1 = i1, & refi2 = i2;
//
//	//refi1 = 200, refi2 = 120;
//
//	//std::cout << refi1 << std::endl << refi2 << std::endl;
//	////引用名就代表原名，和原名同样使用
//	//引用只能够绑定在对象上，且类型与原对象严格匹配，不能够绑定在某个字面量或者计算结果上
//	//int& ref = 10;	//引用初始化对象必须为可修改的左值
//	//double Double = 3.14;
//	//int& refDouble = Double;	//类型不同不能够绑架
//
//	//int i, & ri = i;
//	//i = 5; ri = 10;
//
//	//std::cout << i << ' ' << ri << std::endl;
//	////			10			10
//
//
//
//	//指针
//	/*
//	* 指针(pointer)是指向(point to) 另外一种类型的复合类型
//	* 与引用类似，指针也实现了对其它对象的间接访问
//	* 然而指针与引用相比又有很多不同点
//	* 其一：指针本身就是一个对象，允许指针赋值和拷贝
//	* 而且在指针的生命周期内它可以指向多个不同的对象
//	* 其二：指针无需在定义时赋初值，和其它类型一样，
//	* 在块定义域中的指针未初始化时也拥有一个不确定的值
//	* (ps.在块作用域外的变量未初始化时值为0)
//	*/
//
//	//定义指针类型的方法：
//	//声明为*d，d为变量名，如果定义多个指针变量，则每个变量前都应加*
//	// int *d;
//	//int* d1, * d2;		//两者皆为指向int对象的指针
//	//double dp, * dp2;	//dp为double型变量，dp2则为指向double对象的指针
//
//	////指针存放某个对象的地址
//	////获取地址需使用取地址操作符(&)
//
//	//int val = 42;
//	//int* pval = &val;	//定义一个指向int型对象的指针变量pval并将其初始化为val的地址
//
//	//int& refval = val;
//	//int* prefval = &refval;	//引用不是对象没有实际地址，所以没有指向引用的指针而是指向引用对象的指针
//
//	//指针的类型应与其指向的对象的类型严格对应，否则将会出现使用的错误
//
//	//指针值：
//	//指针值应属于一下四种状态：
//	//1．指向一个对象
//	//2. 指向紧邻对象所占空间的下一个位置
//	//3. 空指针，未指向任何空间
//	//4, 无效指针，不属于上述任何一种情况
//
//	//试图拷贝或以其它方式访问无效指针都将导致错误，编译器不会检查此类错误
//	//2.与3.指针都是有效指针，但未指向任何实体对象，贸然使用将会导致严重后果
//
//	////若指针指向了一个对象，则可以使用解引用操作符(*)来访问该对象
//	//int i = 1;
//	//int* pi = &i;
//	//std::cout << *pi << std::endl;
//	////为指针解引用可以访问指针指向的地址，为解引用的指针赋值将直接为指向的对象赋值
//	//*pi = 100;
//	//std::cout << i << std::endl;
//
//	//空指针
//	//空指针(null pointer)不指向任何对象
//	//在试图使用一个指针之前代码可以首先检测这个指针是否为空指针
//	// int *p1 = nullptr;
//	// int *p2 = 0;
//	// 需头文件#include<cstdlib>
//	// int *p3 = NULL;
//	//
//	//得到空指针最直接的方式是使用字面值nullptr来初始化指针
//	//nullptr是一个特殊的指针，它可以被初始化为任意其它类型的指针
//	//另一种得到空指针的方法就是直接初始化为0(个人不建议使用，因为使代码不够易读)
//	//过去的程序中还会用到一个名为 NULL 的预处理变量(preprocessor variable)来给指针赋值，这个变量在cstdlib中定义，它的值就是0
//	//将int变量直接赋值给指针是错误的操作，即时int的值为0也不行
//	//int zero = 0;
//	//int* pzero = zero;	//X
//
//	//赋值和指针
//	//指针和引用都能提供对其它对象的间接访问，然而在具体实现细节上二者有很大的不同
//	//其中最重要的一点就是引用本身并非一个对象，一旦定义了引用，就无法令其绑定到另外的对象
//	//之后每次的引用都是访问它最初绑定的那个对象
//	//指针和它存放的地址就没有这种限制了和其它任何变量一样，给指针赋值就是令它存放另一个地址，从而指向一个新的对象
//	//
//	//int i = 42;
//	//int* pi = 0;	//pi被初始化但并没有指向任何对象
//	//int* pi2 = &i;	//pi2被初始化并存放i的地址
//	//int* pi3;		//pi3被定义但并未初始化
//	//pi3 = pi2;		//pi2被赋值给pi3
//	//pi2 = 0;		//pi2被置为空指针
//
//	//其它指针操作
//	//只要指针拥有一个合法值，就能将它用在条件表达式中，如果指针为0，条件取false
//	//任何菲林（？）非零指针对应的条件都是true
//	//对于两个类型相同的合法指针，可以用相等操作符(==)或不等操作符(!=)来进行比肩，比较结果为bool值
//	//如果两个指针存放的地址相同则相等，反之则不等
//	//如果两个指针相等，则存放的指针有三种情况:
//	//1. 都为空
//	//2. 都指向同一个对象
//	//3. 都指向了同一个对象的下一个地址
//	//如果两个指针中一个指向了一个对象，另一个指针指向了另一个对象的下一个地址，这时这两个指针可能会相等
//	//上述指针的使用方法都为合法指针，非法指针的使用都将造成严重的后果
//
//	//void* 指针
//	//void* 是一种特殊的指针类型，可用于存放任意对象的地址，void* 指针存放的地址具体类型未知，且无法直接使用
//	//
//	//double obj = 3.14,
//	//	  * pd = &obj;
//	//void* pv = &obj;	//obj可以是任意类型的地址
//	//pv = pd;			//pv可以存放任意类型的地址
//	//void* 指针能做的事情很有限：拿它和别的指针比较，作为函数的输入或输出，或者赋给另外一个void* 指针
//	//不能直接操作void* 指针所指向的对象，因为指向对象的结果未知类型未知，也无法确定这个对象能够进行何种操作
//	//以void* 的视角来看内存空间仅仅是内存空间（听君一席话，如听一席话）
//	//我们无法直接访问void* 所指向的内存空间
//
//
//	//2.3.2节练习
//	////练习2.18:编写代码分别更改指针的值及指针所指向的变量的值
//	//int val = 0;
//	//int* pval = 0;
//	//std::cout << "val:" << val << std::endl;
//	//pval = &val;
//	//std::cout << "pval->" << *pval << std:: endl;
//	//*pval = 114514;
//	//std::cout << "val:" << val << ' ' << "pval->" << *pval << std::endl;
//	//练习2.19:说明指针和引用的主要区别
//	//指针本身就是一类对象而引用是获得对象的别名
//	//练习2.20:请描述下面这段代码的作用
//	//int i = 42;
//	//int* p1 = &i;
//	//*p1 = *p1 * *p1;
//	//将p1指向对象的值的平方赋给p1所指向的对象
//	//练习2.21:请解释下述定义。在这些定义中有非法吗，为什么
//	//int i = 0;
//	//(a)double* dp = &i;
//	//不能将int*类型指针值赋给double*类型变量dp
//	//(b)int *pi = i;
//	//不能键整型变量值当作指针变量直接赋给指针变量，即使这个变量的值为0
//	//(c)int *p = &i;
//	//创建一个整型指针p并初始化为i的地址
//	//练习2.22假设p是一个int型的指针，请说明下述代码的含义
//	//if (p)//...
//	// 判断p是否为空指针
//	//if (*p)//...
//	// 如果p为非空指针则判断p所指向的int型对象的值是否为0
//	//练习2.23给定指针p，你能知道它是否指向了一个合法的对象吗？如果能，叙述判断的思路；如果不能，也请说明原因
//	//不能，因为我并不知道这个指针所指向对象的类型
//	//练习2.24在下面这段代码中为什么p合法而lp非法
//	//int i = 42;
//	//void* p = &i;
//	//long* lp = &i;
//	//void* 类型的指针变量可以存放任意类型指针变量的值，而其它类型指针变量只能存储其类型指针变量的值
//
//	
//	std::cout << "Hello World" << std::endl;
//	return 0;
//}

//20221122
int main()
{
	//2.3.3 理解复合类型的声明
	//如前所述 变量的定义包括一个基本数据类型(base type)和一组声明符。
	//在同一条定义语句中，虽然基本数据类型只有一个，但声明符的形式却可以不同。
	//也就是说，同一条定义语句可能定义出不同类型的变量:
	// int i = 1024, * p = &i, & r = i;
	//定义多个变量
	//定义多个变量时，每一个类型修饰符都只作用于它身后的一个变量名
	//标准写法为：
	// int* p, * p1;
	//或
	// int* p;
	// int* p1;
	//指向指针的指针
	//一般来说，修饰界定符的数量并没有限制
	//指针是一类对象，在内存中也有自己的地址，因此也允许将一个指针的地址放入另一个指针中
	//通过*的个数可以区分指针的级别，*是指针，**是指向指针的指针，***则是指向指针的指针的指针，以此类推
	//int val = 10;
	//int* pval = &val;
	//int** ppval = &pval;
	//std::cout << val << '\n'
	//	<< *pval << '\n'
	//	<< **ppval << std::endl;
	//指向指针的引用
	////指针是对象，所以存在指向指针的引用，而引用不是对象，所以不存在指向引用的指针
	//int i = 42;
	//int* pi = &i;		//pi是一个int型指针
	//int*& rpi = pi;		//rpi是对指针pi的引用
	//
	//rpi = &i;			//rpi是对指针的引用，该语句作用是将i的地址赋给pi
	//*rpi = 0;			//对rpi解引用就等同于对pi解引用
	//要理解rpi是什么，最简单的方式就是从右至左阅读rpi的定义
	//&证明rpi是一个引用，而int*证明rpi引用的是一个int的地址
	//2.3.3练习
	//说明下列变量的类型和值
	//(a)int* pi, i, & r = i;
	//pi是一个指向int型对象的指针，i是一个int型变量，r是对int型对象的引用
	//(b)int i, * p = 0;
	//i是一个int型变量，p是一个指向int型对象的空指针
	//(c)int* ip, ip2;
	//ip是一个指向int型对象的指针，ip2是一个int型变量


	return 0;
}