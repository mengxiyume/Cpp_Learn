#define _CRT_SECURE_NO_WARNINGS

#include<iostream>

int main()
{

	//引用
	//int a = 0;

	//int& refa = a;		//reference引用
	//					//refa与右值绑定bind
	//
	//std::cout << refa++ << std::endl;
	//std::cout << a << std::endl;

	// //int& refb;			//refb必须初始化
	//
	//int i1 = 0, i2 = 0;
	//int& refi1 = i1, & refi2 = i2;

	//refi1 = 200, refi2 = 120;

	//std::cout << refi1 << std::endl << refi2 << std::endl;
	////引用名就代表原名，和原名同样使用
	//引用只能够绑定在对象上，且类型与原对象严格匹配，不能够绑定在某个字面量或者计算结果上
	//int& ref = 10;	//引用初始化对象必须为可修改的左值
	//double Double = 3.14;
	//int& refDouble = Double;	//类型不同不能够绑架

	//int i, & ri = i;
	//i = 5; ri = 10;

	//std::cout << i << ' ' << ri << std::endl;
	////			10			10
	


	//指针
	/*
	* 指针(pointer)是指向(point to) 另外一种类型的复合类型
	* 与引用类似，指针也实现了对其它对象的间接访问
	* 然而指针与引用相比又有很多不同点
	* 其一：指针本身就是一个对象，允许指针赋值和拷贝
	* 而且在指针的生命周期内它可以指向多个不同的对象
	* 其二：指针无需在定义时赋初值，和其它类型一样，
	* 在块定义域中的指针未初始化时也拥有一个不确定的值
	* (ps.在块作用域外的变量未初始化时值为0)
	*/

	//定义指针类型的方法：
	//声明为*d，d为变量名，如果定义多个指针变量，则每个变量前都应加*
	// int *d;
	int* d1, * d2;		//两者皆为指向int对象的指针
	double dp, * dp2;	//dp为double型变量，dp2则为指向double对象的指针

	//指针存放某个对象的地址
	//获取地址需使用取地址操作符(&)

	int val = 42;
	int* pval = &val;	//定义一个指向int型对象的指针变量pval并将其初始化为val的地址

	//int& refval = val;
	//int* prefval = &refval;	//引用不是对象没有实际地址，所以没有指向引用的指针而是指向引用对象的指针

	//指针的类型应与其指向的对象的类型严格对应，否则将会出现使用的错误

	//指针值：
	//指针值应属于一下四种状态：
	//1．指向一个对象
	//2. 指向紧邻对象所占空间的下一个位置
	//3. 空指针，未指向任何空间
	//4, 无效指针，不属于上述任何一种情况

	//试图拷贝或以其它方式访问无效指针都将导致错误，编译器不会检查此类错误
	//2.与3.指针都是有效指针，但未指向任何实体对象，贸然使用将会导致严重后果

	//若指针指向了一个对象，则可以使用解引用操作符(*)来访问该对象
	int i = 1;
	int* pi = &i;
	std::cout << *pi << std::endl;
	//为指针解引用可以访问指针指向的地址，为解引用的指针赋值将直接为指向的对象赋值
	*pi = 100;
	std::cout << i << std::endl;

	std::cout << "Hello World" << std::endl;
	return 0;
}