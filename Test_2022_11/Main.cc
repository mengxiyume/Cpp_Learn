#define _CRT_SECURE_NO_WARNINGS

#include<iostream>

int main()
{

	//引用
	//int a = 0;

	//int& refa = a;		//reference引用
	//					//refa与右值绑定bind
	//
	//std::cout << refa++ << std::endl;
	//std::cout << a << std::endl;

	// //int& refb;			//refb必须初始化
	//
	//int i1 = 0, i2 = 0;
	//int& refi1 = i1, & refi2 = i2;

	//refi1 = 200, refi2 = 120;

	//std::cout << refi1 << std::endl << refi2 << std::endl;
	////引用名就代表原名，和原名同样使用
	//引用只能够绑定在对象上，且类型与原对象严格匹配，不能够绑定在某个字面量或者计算结果上
	//int& ref = 10;	//引用初始化对象必须为可修改的左值
	//double Double = 3.14;
	//int& refDouble = Double;	//类型不同不能够绑架

	//int i, & ri = i;
	//i = 5; ri = 10;

	//std::cout << i << ' ' << ri << std::endl;
	////			10			10



	//指针
	/*
	* 指针(pointer)是指向(point to) 另外一种类型的复合类型
	* 与引用类似，指针也实现了对其它对象的间接访问
	* 然而指针与引用相比又有很多不同点
	* 其一：指针本身就是一个对象，允许指针赋值和拷贝
	* 而且在指针的生命周期内它可以指向多个不同的对象
	* 其二：指针无需在定义时赋初值，和其它类型一样，
	* 在块定义域中的指针未初始化时也拥有一个不确定的值
	* (ps.在块作用域外的变量未初始化时值为0)
	*/

	//定义指针类型的方法：
	//声明为*d，d为变量名，如果定义多个指针变量，则每个变量前都应加*
	// int *d;
	//int* d1, * d2;		//两者皆为指向int对象的指针
	//double dp, * dp2;	//dp为double型变量，dp2则为指向double对象的指针

	////指针存放某个对象的地址
	////获取地址需使用取地址操作符(&)

	//int val = 42;
	//int* pval = &val;	//定义一个指向int型对象的指针变量pval并将其初始化为val的地址

	//int& refval = val;
	//int* prefval = &refval;	//引用不是对象没有实际地址，所以没有指向引用的指针而是指向引用对象的指针

	//指针的类型应与其指向的对象的类型严格对应，否则将会出现使用的错误

	//指针值：
	//指针值应属于一下四种状态：
	//1．指向一个对象
	//2. 指向紧邻对象所占空间的下一个位置
	//3. 空指针，未指向任何空间
	//4, 无效指针，不属于上述任何一种情况

	//试图拷贝或以其它方式访问无效指针都将导致错误，编译器不会检查此类错误
	//2.与3.指针都是有效指针，但未指向任何实体对象，贸然使用将会导致严重后果

	////若指针指向了一个对象，则可以使用解引用操作符(*)来访问该对象
	//int i = 1;
	//int* pi = &i;
	//std::cout << *pi << std::endl;
	////为指针解引用可以访问指针指向的地址，为解引用的指针赋值将直接为指向的对象赋值
	//*pi = 100;
	//std::cout << i << std::endl;

	//空指针
	//空指针(null pointer)不指向任何对象
	//在试图使用一个指针之前代码可以首先检测这个指针是否为空指针
	// int *p1 = nullptr;
	// int *p2 = 0;
	// 需头文件#include<cstdlib>
	// int *p3 = NULL;
	//
	//得到空指针最直接的方式是使用字面值nullptr来初始化指针
	//nullptr是一个特殊的指针，它可以被初始化为任意其它类型的指针
	//另一种得到空指针的方法就是直接初始化为0(个人不建议使用，因为使代码不够易读)
	//过去的程序中还会用到一个名为 NULL 的预处理变量(preprocessor variable)来给指针赋值，这个变量在cstdlib中定义，它的值就是0
	//将int变量直接赋值给指针是错误的操作，即时int的值为0也不行
	//int zero = 0;
	//int* pzero = zero;	//X

	//赋值和指针
	//指针和引用都能提供对其它对象的间接访问，然而在具体实现细节上二者有很大的不同
	//其中最重要的一点就是引用本身并非一个对象，一旦定义了引用，就无法令其绑定到另外的对象
	//之后每次的引用都是访问它最初绑定的那个对象
	//指针和它存放的地址就没有这种限制了和其它任何变量一样，给指针赋值就是令它存放另一个地址，从而指向一个新的对象
	//
	//int i = 42;
	//int* pi = 0;	//pi被初始化但并没有指向任何对象
	//int* pi2 = &i;	//pi2被初始化并存放i的地址
	//int* pi3;		//pi3被定义但并未初始化
	//pi3 = pi2;		//pi2被赋值给pi3
	//pi2 = 0;		//pi2被置为空指针

	//其它指针操作
	//只要指针拥有一个合法值，就能将它用在条件表达式中，如果指针为0，条件取false
	//任何菲林（？）非零指针对应的条件都是true
	//对于两个类型相同的合法指针，可以用相等操作符(==)或不等操作符(!=)来进行比肩，比较结果为bool值
	//如果两个指针存放的地址相同则相等，反之则不等
	//如果两个指针相等，则存放的指针有三种情况:
	//1. 都为空
	//2. 都指向同一个对象
	//3. 都指向了同一个对象的下一个地址
	//如果两个指针中一个指向了一个对象，另一个指针指向了另一个对象的下一个地址，这时这两个指针可能会相等
	//上述指针的使用方法都为合法指针，非法指针的使用都将造成严重的后果

	//void* 指针
	//void* 是一种特殊的指针类型，可用于存放任意对象的地址，void* 指针存放的地址具体类型未知，且无法直接使用
	//
	//double obj = 3.14,
	//	  * pd = &obj;
	//void* pv = &obj;	//obj可以是任意类型的地址
	//pv = pd;			//pv可以存放任意类型的地址
	//void* 指针能做的事情很有限：拿它和别的指针比较，作为函数的输入或输出，或者赋给另外一个void* 指针
	//不能直接操作void* 指针所指向的对象，因为指向对象的结果未知类型未知，也无法确定这个对象能够进行何种操作
	//以void* 的视角来看内存空间仅仅是内存空间（听君一席话，如听一席话）
	//我们无法直接访问void* 所指向的内存空间


	//2.3.2节练习
	////练习2.18:编写代码分别更改指针的值及指针所指向的变量的值
	//int val = 0;
	//int* pval = 0;
	//std::cout << "val:" << val << std::endl;
	//pval = &val;
	//std::cout << "pval->" << *pval << std:: endl;
	//*pval = 114514;
	//std::cout << "val:" << val << ' ' << "pval->" << *pval << std::endl;
	//练习2.19:说明指针和引用的主要区别
	//指针本身就是一类对象而引用是获得对象的别名
	//练习2.20:请描述下面这段代码的作用
	//int i = 42;
	//int* p1 = &i;
	//*p1 = *p1 * *p1;
	//将p1指向对象的值的平方赋给p1所指向的对象
	//练习2.21:请解释下述定义。在这些定义中有非法吗，为什么
	//int i = 0;
	//(a)double* dp = &i;
	//不能将int*类型指针值赋给double*类型变量dp
	//(b)int *pi = i;
	//不能键整型变量值当作指针变量直接赋给指针变量，即使这个变量的值为0
	//(c)int *p = &i;
	//创建一个整型指针p并初始化为i的地址
	//练习2.22假设p是一个int型的指针，请说明下述代码的含义
	//if (p)//...
	// 判断p是否为空指针
	//if (*p)//...
	// 如果p为非空指针则判断p所指向的int型对象的值是否为0
	//练习2.23给定指针p，你能知道它是否指向了一个合法的对象吗？如果能，叙述判断的思路；如果不能，也请说明原因
	//不能，因为我并不知道这个指针所指向对象的类型
	//练习2.24在下面这段代码中为什么p合法而lp非法
	//int i = 42;
	//void* p = &i;
	//long* lp = &i;
	//void* 类型的指针变量可以存放任意类型指针变量的值，而其它类型指针变量只能存储其类型指针变量的值

	
	std::cout << "Hello World" << std::endl;
	return 0;
}